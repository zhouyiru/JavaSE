package 线程体系;
/*

进程： 正在运行 的程序称作为一个进程。 进程负责了内存空间的划分。

线程：线程负责了一个进程中的代码执行， 也就是一个进程中的执行路径。


多线程： 一个进程中有多个线程。


多线程的好处: 
	1. 解决了一个进程中可以同时执行多个任务的问题。
	2. 提高了资源利用率

多线程的弊端：
	1. 增加了cpu的负担
	2. 降低了一个进程中线程的执行概率。
	3. 出现了线程安全问题
	4. 出现了死锁现象。
	

自定义线程的步骤：
	
	方式一：  通过Thread类。
		1. 自定义一个类继承Thread。
		2. 重写Thread类的run方法，把自定义线程的任务代码定义在run方法上。
		3. 创建Thread子类对象，并且调用start方法开启线程。
	
	方式二：
		1. 自定义一个类实现Runnable接口。
		2. 实现Runnable接口的run方法， 把自定义线程的任务代码定义在run方法上。
		3. 创建Runnable实现类的对象。
		4. 创建Thread类的对象，并且把Runnable实现类的对象作为参数传递。
		5. 调用Thread对象的start方法开启线程。
		
推荐使用： 实现Ruannble接口


线程安全问题：

线程安全问题出现的根本原因： 
	1. 存在两个或者两个以上的线程。
	2. 多个线程共享了一个资源，而且操作资源的代码有多句。
	
	
 	解决方案一：使用同步代码块
 
 		synchronized(锁){
 			需要同步的代码;
 		}
 	同步代码块要注意的细节：
 		1. 锁对象可以是任意的对象
 		2. 锁对象必须是多个线程共享的对象。
 		3. 一个线程调用了sleep方法不会释放锁对象，一个线程如果调用wait方法会释放锁对象。
 		4. 如果没有出现线程安全问题，不要 随便使用java的同步机制。
 	
 	
 	解决方案二： 使用同步函数。
 		1. 非静态的同步函数的锁对象this对象， 静态同步函数 的锁对象是当前所属的类的class文件对象。
 		2. 同步函数 的锁对象是固定 的，不能随意的指定。
 		

线程通讯：	

	wait()  如果一个线程调用了wait方法，那么该线程会进入以锁对象作为标识符的一个线程池中等待。
	notify()  如果一个线程调用了notify方法，那么该线程会唤醒以锁对象作为标识符线程池中等待线程的一个。
	
	
	wait()与notify方法调用要注意的事项：
		1. wait（） notify、 notifyAll() 这些方法都是属于Object类。
		2. wait（） notify、 notifyAll() 这些方法必须要在同步代码块或者是同步函数中调用。
		3. wait（） notify、 notifyAll() 这些方法必须要有锁对象调用。


网络编程： 分布在不同地域计算机可以互相传递消息、共享资源。 

网页编程： 基与html页面计算机与服务器之间的通讯。。 

网络编程的三要素：
	1. IP
	2. 端口号。  (0~65535)   1024 ~ 6635
	3. 协议  （udp协议、 tcp协议）
	
 */




